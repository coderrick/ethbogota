"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printTrace = void 0;
const utils_1 = require("ethers/lib/utils");
const colors_1 = require("../colors");
const constants_1 = require("../constants");
const utils_2 = require("../utils");
const call_1 = require("./format/call");
const contract_1 = require("./format/contract");
const call_2 = require("./opcodes/call");
const callcode_1 = require("./opcodes/callcode");
const create_1 = require("./opcodes/create");
const create2_1 = require("./opcodes/create2");
const delegatecall_1 = require("./opcodes/delegatecall");
const log0_1 = require("./opcodes/log0");
const log1_1 = require("./opcodes/log1");
const log2_1 = require("./opcodes/log2");
const log3_1 = require("./opcodes/log3");
const log4_1 = require("./opcodes/log4");
const revert_1 = require("./opcodes/revert");
const sload_1 = require("./opcodes/sload");
const sstore_1 = require("./opcodes/sstore");
const staticcall_1 = require("./opcodes/staticcall");
async function printTrace(txHash, dependencies) {
    var _a;
    const addressStack = [];
    try {
        const res = await dependencies.provider.send("debug_traceTransaction", [
            txHash,
            { disableStorage: true },
        ]);
        const tx = await dependencies.provider.send("eth_getTransactionByHash", [
            txHash,
        ]);
        if (tx.to !== null &&
            tx.to !== "0x" &&
            tx.to !== "0x0000000000000000000000000000000000000000") {
            // normal transaction
            console.log((0, colors_1.colorLabel)("CALL") +
                " " +
                (await (0, call_1.formatCall)(tx.to, tx.input, "0x", tx.value, tx.gas, dependencies)));
            addressStack.push(tx.to);
        }
        else {
            // contract deploy transaction
            const str = await (0, contract_1.formatContract)(tx.input, (0, utils_2.parseUint)((_a = tx.value) !== null && _a !== void 0 ? _a : "0x"), null, (0, utils_1.getContractAddress)(tx), dependencies);
            addressStack.push((0, utils_1.getContractAddress)(tx));
            console.log((0, colors_1.colorLabel)("CREATE") + " " + str);
        }
        for (const [i, structLog] of res.structLogs.entries()) {
            await printStructLog(structLog, i, res.structLogs, addressStack, dependencies);
        }
    }
    catch (error) {
        // if debug_traceTransaction failed then print warning
        if (error.message.includes("debug_traceTransaction")) {
            console.log((0, colors_1.colorWarning)(`Warning! Debug Transaction not supported on this network`));
        }
        else {
            // else print what the error is
            console.error(error);
        }
    }
}
exports.printTrace = printTrace;
async function printStructLog(structLog, index, structLogs, addressStack, dependencies) {
    // if running in logs mode exit if opcode is not a LOG
    if ((0, utils_2.isOnlyLogs)(dependencies.tracerEnv) && !structLog.op.startsWith("LOG")) {
        return;
    }
    switch (structLog.op) {
        case "CREATE":
            addressStack.push(await (0, create_1.printCreate)(structLog, index, structLogs, dependencies));
            break;
        case "CREATE2":
            addressStack.push(await (0, create2_1.printCreate2)(structLog, index, structLogs, dependencies));
            break;
        case "CALL":
            addressStack.push(await (0, call_2.printCall)(structLog, index, structLogs, dependencies));
            break;
        case "CALLCODE":
            await (0, callcode_1.printCallCode)(structLog, index, structLogs, dependencies);
            break;
        case "STATICCALL":
            addressStack.push(await (0, staticcall_1.printStaticCall)(structLog, index, structLogs, dependencies));
            break;
        case "DELEGATECALL":
            addressStack.push(addressStack[addressStack.length - 1]);
            await (0, delegatecall_1.printDelegateCall)(structLog, index, structLogs, dependencies);
            break;
        case "LOG0":
            await (0, log0_1.printLog0)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "LOG1":
            await (0, log1_1.printLog1)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "LOG2":
            await (0, log2_1.printLog2)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "LOG3":
            await (0, log3_1.printLog3)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "LOG4":
            await (0, log4_1.printLog4)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "SLOAD":
            if (dependencies.tracerEnv.sloads) {
                await (0, sload_1.printSload)(structLog, index, structLogs, dependencies);
            }
            break;
        case "SSTORE":
            if (dependencies.tracerEnv.sstores) {
                await (0, sstore_1.printSstore)(structLog, dependencies);
            }
            break;
        case "REVERT":
            await (0, revert_1.printRevert)(structLog, dependencies);
            addressStack.pop();
            break;
        case "RETURN":
            addressStack.pop();
            break;
        case "STOP":
            addressStack.pop();
            break;
        default:
            if (dependencies.tracerEnv.opcodes.includes(structLog.op)) {
                console.log(constants_1.DEPTH_INDENTATION.repeat(structLog.depth) + structLog.op);
            }
            break;
    }
}
//# sourceMappingURL=print-trace.js.map